深度缓冲就像颜色缓冲(Color Buffer)（储存所有的片段颜色：视觉输出）一样，在每个片段中储存了信息，并且（通常）和颜色缓冲有着一样的宽度和高度。
深度缓冲是由窗口系统自动创建的，它会以16、24或32位float的形式储存它的深度值。
在大部分的系统中，深度缓冲的精度都是24位的。

当深度测试(Depth Testing)被启用的时候，OpenGL会将一个片段的的深度值与深度缓冲的内容进行对比。
OpenGL会执行一个深度测试，如果这个测试通过了的话，深度缓冲将会更新为新的深度值。
如果深度测试失败了，片段将会被丢弃。

深度缓冲是在片段着色器运行之后以及模板测试(Stencil Testing)运行之后，在屏幕空间中运行的。
屏幕空间坐标与通过OpenGL的glViewport所定义的视口密切相关，并且可以直接使用GLSL内建变量gl_FragCoord从片段着色器中直接访问。
gl_FragCoord的x和y分量代表了片段的屏幕空间坐标（其中(0, 0)位于左下角）。

OpenGL允许我们修改深度测试中使用的比较运算符。
这允许我们来控制OpenGL什么时候该通过或丢弃一个片段，什么时候去更新深度缓冲。
我们可以调用glDepthFunc函数来设置比较运算符（或者说深度函数(Depth Function)）：
这个函数接受下面表格中的比较运算符：
	函数	描述
	GL_ALWAYS	永远通过深度测试
	GL_NEVER	永远不通过深度测试
	GL_LESS	在片段深度值小于缓冲的深度值时通过测试
	GL_EQUAL	在片段深度值等于缓冲区的深度值时通过测试
	GL_LEQUAL	在片段深度值小于等于缓冲区的深度值时通过测试
	GL_GREATER	在片段深度值大于缓冲区的深度值时通过测试
	GL_NOTEQUAL	在片段深度值不等于缓冲区的深度值时通过测试
	GL_GEQUAL	在片段深度值大于等于缓冲区的深度值时通过测试
默认情况下使用的深度函数是GL_LESS，它将会丢弃深度值大于等于当前深度缓冲值的所有片段。

将深度函数改为GL_ALWAYS,这将会模拟我们没有启用深度测试时所得到的结果。
深度测试将会永远通过，所以最后绘制的片段将会总是会渲染在之前绘制片段的上面，即使之前绘制的片段本就应该渲染在最前面。


深度冲突
	一个很常见的视觉错误会在两个平面或者三角形非常紧密地平行排列在一起时会发生，深度缓冲没有足够的精度来决定两个形状哪个在前面。
	结果就是这两个形状不断地在切换前后顺序，这会导致很奇怪的花纹。
	这个现象叫做深度冲突(Z-fighting)，因为它看起来像是这两个形状在争夺(Fight)谁该处于顶端。

	在我们一直使用的场景中，有几个地方的深度冲突还是非常明显的。
	箱子被放置在地板的同一高度上，这也就意味着箱子的底面和地板是共面的(Coplanar)。
	这两个面的深度值都是一样的，所以深度测试没有办法决定应该显示哪一个。

	如果你将摄像机移动到其中一个箱子的内部，你就能清楚地看到这个效果的，箱子的底部不断地在箱子底面与地板之间切换，形成一个锯齿的花纹：


	深度冲突是深度缓冲的一个常见问题，当物体在远处时效果会更明显（因为深度缓冲在z值比较大的时候有着更小的精度）。
	深度冲突不能够被完全避免，但一般会有一些技巧有助于在你的场景中减轻或者完全避免深度冲突、

	防止深度冲突
	第一个也是最重要的技巧是永远不要把多个物体摆得太靠近，以至于它们的一些三角形会重叠。
	通过在两个物体之间设置一个用户无法注意到的偏移值，你可以完全避免这两个物体之间的深度冲突。
	在箱子和地板的例子中，我们可以将箱子沿着正y轴稍微移动一点。
	箱子位置的这点微小改变将不太可能被注意到，但它能够完全减少深度冲突的发生。
	然而，这需要对每个物体都手动调整，并且需要进行彻底的测试来保证场景中没有物体会产生深度冲突。

	第二个技巧是尽可能将近平面设置远一些。
	在前面我们提到了精度在靠近近平面时是非常高的，所以如果我们将近平面远离观察者，我们将会对整个平截头体有着更大的精度。
	然而，将近平面设置太远将会导致近处的物体被裁剪掉，所以这通常需要实验和微调来决定最适合你的场景的近平面距离。

	另外一个很好的技巧是牺牲一些性能，使用更高精度的深度缓冲。
	大部分深度缓冲的精度都是24位的，但现在大部分的显卡都支持32位的深度缓冲，这将会极大地提高精度。
	所以，牺牲掉一些性能，你就能获得更高精度的深度测试，减少深度冲突。

	我们上面讨论的三个技术是最普遍也是很容易实现的抗深度冲突技术了。还有一些更复杂的技术，但它们依然不能完全消除深度冲突。
	深度冲突是一个常见的问题，但如果你组合使用了上面列举出来的技术，你可能不会再需要处理深度冲突了。