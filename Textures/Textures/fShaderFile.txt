//第五步片段着色器fragment shader
	/*
		片段着色器只需要一个输出变量，这个变量是一个4分量向量，它表示的是最终的输出颜色。
		我们可以用out关键字声明输出变量，这里我们命名为FragColor。
		我们将一个alpha值为1.0(1.0代表完全不透明)的橘黄色的vec4赋值给颜色输出。
	*/
	/*
		如果我们打算从一个着色器向另一个着色器发送数据，我们必须在发送方着色器中声明一个输出，在接收方着色器中声明一个类似的输入。
		当类型和名字都一样的时候，OpenGL就会把两个变量链接到一起，它们之间就能发送数据了（这是在链接程序对象时完成的）。
	*/
	/*
		Uniform是一种******从CPU中的应用向GPU中的着色器发送数据的方式**********，但uniform和顶点属性有些不同。
		首先，uniform是全局的(Global)。
			全局意味着uniform变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。
		第二，无论你把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。
		我们可以在一个着色器中添加uniform关键字至类型和变量名前来声明一个GLSL的uniform。
		从此处开始我们就可以在着色器中使用新声明的uniform了

	*/

	/*
		片段着色器应该接下来会把输出变量TexCoord作为输入变量。
		片段着色器也应该能访问纹理对象，但是我们怎样能把纹理对象传给片段着色器呢？GLSL有一个供纹理对象使用的内建数据类型，叫做采样器(Sampler)，它以纹理类型作为后缀，比如sampler1D、sampler3D，或在我们的例子中的sampler2D。
		我们可以简单声明一个uniform sampler2D把一个纹理添加到片段着色器中，稍后我们会把纹理赋值给这个uniform。
		使用GLSL内建的texture函数来采样纹理的颜色，它第一个参数是纹理采样器，第二个参数是对应的纹理坐标。
		texture函数会使用之前设置的纹理参数对相应的颜色值进行采样。这个片段着色器的输出就是纹理的（插值）纹理坐标上的(过滤后的)颜色。
	*/
	
	/*
	GLSL内建的mix函数需要接受两个值作为参数，并对它们根据第三个参数进行线性插值。
	如果第三个值是0.0，它会返回第一个输入；如果是1.0，会返回第二个输入值。
	0.2会返回80%的第一个输入颜色和20%的第二个输入颜色，即返回两个纹理的混合色。
	*/


 #version 330 core
out vec4 FragColor;

in vec3 ourColor;
in vec2 TexCoord;

uniform sampler2D texture1;
uniform sampler2D texture2;

//uniform vec4 ourColor;
void main()
{
	//FragColor = texture(texture1, TexCoord) * vec4(ourColor, 1.0);
	FragColor = mix(texture(texture1, TexCoord), texture(texture2, vec2(1.0 - TexCoord.x, TexCoord.y)), 0.2);
}